// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

class d
enum S<T where A? {
class a {
protocol A.b<T where H:d<h : d func b
var f {{struct B<T where H:e: String = compose<T where H:A.b<h: String = nil
func a<}struct c,
var f = "[1)"[1)"[1)"
class d{var f = compose<T {
func A.Generator
func a<T where h: d
}
struct c>
extension g<h: T
}
protocol A {
class A? {
return "\()"\(e
class func a
class d
class d{
class d{protocol A {
class a {
let a = T> : T
}var f = nil
class a
func b: d = compose<U : Array) {
enum S<}
enum S<T where H.Generator
protocol A? {
protocol A{protocol A {
class B
{
protocol A {
protocol c : NSManagedObject {
struct c>
enum b
}
class func a
struct c>
protocol A {
func b: a {
struct B
enum S<T
let a {
enum S<U : NSManagedObject {
class d
{
class B
enum S<d
enum B : d{
extension S<T {
class func a{
class d
class A {{
struct D : A? {
class B<U : Any, A? {
let a {
}
}
class B
struct D : NSManagedObject {{
func a{
switch x }struct c>: Any, A.B : d{{
class A: A
class A.b
let a<T
}
let end = compose<T {
class d
protocol A {
class d
(e: d<T
protocol A : A{
if true {
struct c<T where H.B : AnyObject, A: Any, A<T {
struct B
class func a<h : T
}
class a {
let a = A.dynamicType)
typealias e: Array) {
func a
(e
func a{
}
class B
}struct c>
class a
class A {
}
protocol A : a = T
class
}
{
class d
var f = nil
protocol A {
}
var f = nil
struct c>: a {
struct c>
func a<T : T
class a
func a
let a {
typealias f=b: a = compose<T> : B
struct A : Any, A: d
class b: Any, x in 0
let c {
func b{
class func b
class func a
let a {
protocol c : A{
class B<h : Any, x }
func g<U : T>: A{
class d
}
let a {extension g<h : T> : AnyObject, A.b
let a = T
protocol A
}
}
protocol A : B
enum S{func a{
enum S<T where T
func a
class A? {
protocol f = T> : T
class A{
func a<T
extension S<h: Any, x }
struct c{
func b: NSManagedObject {
}
class d
struct A : Array) {
class d
}
enum S<T where H.dynamicType)
struct S<h : d
func a
enum S:A? {
class a {
var f = "[1)
}
}
let c : Any, x }
extension S<}
enum B {
class A {
protocol a
protocol A : A{
class A : a
struct D : String = T
let a {
enum S<h : Array) {
func b
}
struct A : a
protocol A {
var f = ""[1)"\(e: d = compose<T:B<T
class A: a<h: A
func b
var f = "
struct d<T where H.dynamicType)
let c : Any, x }
enum S:d
class a {
class A : B
enum S<T where h: Any, x in 0
class a
class A : T:e: T
struct B
switch x }
}
class A {struct c<H.b: a<

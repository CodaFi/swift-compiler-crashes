// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

struct S<T where B<U : A {
"
}
class d
struct S
protocol e = compose(f: C
i> c : C
func b
(f: e
var e) { func c,j where B<T {
i> Void{
class A
class B{
"\(false)?
protocol c : b { func b
class B<T>(f: c : d
"
{
typealias F = []
protocol c : b { ) -> Void{
[]
protocol c { func c
class A
class A
func a
struct A {
protocol c : e: d {
struct A {
struct S<e: d{
Void{
struct A {
case c,
protocol c : B<e>: b { func a
"
let f = [Void{
struct Q<Int>
class B<T>: Any)?
let start = [Void{
class d<T where T> : d = T>
protocol c : c : b = [Void{
case c
"\(false)
protocol c {func a<T where T.c<T>: d = B:A:(f: d
{
{
func a<T where S<T : b { func a<T where T>: e = [Void{
let end = compose() in x = B {
{
struct S<T : d = [[Void{
{
protocol c : b { func b:a<T where T>: e
b
{
protocol e = B {
class d{
class
struct c
var d {
struct B
struct A {
var e>: {
([Void{
class A
let f = B<d = [[Void{
case c
H.C
var d = [Void{
[Void{
"
struct S<f = {
class c : d = [Void{
case c
protocol c : c : b let f = {
func b
let f :S<Int> c { }
func a
let g<Int>
class d<f = [Void{
([]
struct S
class d,
if true{
class {
struct S
func b
protocol c {
struct Q<T where T:(f: d
"
class A {
case c,
struct A {
Void{
b { func c,
"
"
"
" "\((f: d = [Void{
struct S
i> Void{
class d<T>
struct Q<Int>: c : e) { func b
"\((x: b { func b<T: S<e: b { func d
protocol e = d<T where T>: e d = B T: c {
"\(false)?
[]
struct S
Void{
struct S<T>: d = compose(f: e) { func a
class
func c
class
struct c,j where h:((([[Void{
protocol c { func b
func b
i> c {
b<T {
protocol c { func a<T where S
i> Void{
((false)?
protocol c { func b:
if true {
b<Int> c { func c,
[]
protocol B<T>
struct S<T = [Void{
struct A {
struct B<T where T: Any)?
let b<Int>
H.C
func c
[Void{
struct A:T>() { func a<d<T where S<T
func a<T>(object1: e
protocol c {
if true {
b = c { func b<f = [Void{
i> Void{
class B{
protocol B<T : d where j=d<T where h:
typealias F = [[Void{
{
b<T : d {
[]
i> {
func b<d f = [Void{
class d<T where S
case c
("\(object1: c { ) -> Void{
i> Void{
var e
struct S<T : c,j where T>: ([Void{
struct B<T where B{
class c : (object1: B<T>: c { func c
{
struct Q<T>: e
{

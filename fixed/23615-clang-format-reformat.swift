// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

protocol B : a {
func a
{
case c
class
case c
var d where f
protocol a
class
{
class a {
case c,
case c,
}
struct - > (true as a<T : a< where B : d<Int>: A {
let start = a"
func a
var b {
func ^(a"
() as String) {
struct A {
let i { func a
"
let end = [ {
protocol B : e
func a
let start = [Void{
protocol b { f
let end = c,
typealias e {
protocol a {
let f : a {
struct d<T{
let end = [Void{
struct g<ff where H.a<f = [Void{
struct A {
typealias e?
i>: S<T : b {}
struct d<T {
let a {
struct S<T where H.b { {
struct - > (array:e
}
protocol a {
let i { func c,
{
func a<b
println( 1 )
"
}}let start = i{
struct A {
protocol
protocol B : a
let end = e
typealias e {
let end = a"
class B<d<T where S<T:c
struct g<b
typealias e {
{
protocol a<T> ) {}
case c
var d = [Void{{
T where B : T where k.h{
func a<T>: b { f
func a
let end = f
class
struct d<d where f
struct g<T>(true as a<T where g<T where H.a< where H.h
class
func b
class
case c,
class A {
var b {
class B : g = f
struct A {
let end = f
struct A {
(true as a
var d where I.= [ {{{
let a {
let a {
let g {
class B<T where I.b : T where I.b {
protocol a : T where k.h : a<T where S
struct Q< {
println(array:T>() {}
func b
println() {
func a
}
protocol B "
let start = [ {
protocol a {
protocol a"
let end = [ {
typealias e
case c,
protocol c : b {
}{
}
}
class
func a!
struct S
class d
let end = f
}
struct g<T : e
}
class A? {
case c}class B? {func a<T T>: P {
class
protocol a {
protocol b { f=}
class
let g = e
class
struct A {
class
(v: B<T> (true as a<T>: A<T : d<T>: T where I.h where H.= [ {
}
let a : T where B : e?
class A {
struct d
0.b {
let end = f
struct B<T>: A<T : B<T where H.h
class A {
func a
protocol a<T where H.h : A {
}
func a
struct A {
func ^(v: S<ff where h:T>
{
protocol B : b = B<Int>: e
}
}
{
let end = [ {
(array:a<ff where I.b { f
}
class B? {
}typealias e {
class
struct B : e
typealias e
class
let i { f
var d where I.b {
}
var b : e.h where B : e : b {
protocol a {
let start = [ {
struct A {
protocol b : e
let end = [Void{
protocol B B : e
}
struct d<T : e = [Void{
let end = f=c,
case c,
typealias e : g = f
struct A {
T {
struct B<T where g.h{
struct B : e.h
func b
static {
deinit {
protocol B : B<T where I.= [Void{
var b = f
protocol B : B? {func a
func a"
class
protocol B : e {
struct

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

class a {
enum b<h {
let a {
protocol A {
}
struct Q<T where g: p
{
let t: e
}
let f = [Void{
func c<T {
enum S<T {
protocol A {
var b: e
func j<T : Int -> {
class d<h where h: e : T
class a
enum a<T where B { func b<h {
struct B
{
protocol A {
class b
protocol A : a {
class A : A
func c<h {
struct B { func b
class A : BooleanType, A {
struct B
struct B
typealias e == [Void
case c
}
class d<T where h: e)"\() -> {
protocol c
}
class A {
extension String {
struct B
if true {
func c( ) -> {
typealias e : BooleanType, A : e)"[1)"[Void
enum S<T where g: AnyObject
class A {
protocol A : Int = c<h where B : a
class b: e
extension String {
struct B : a {
typealias e : d {
struct B : A
class
let f = c( )"[1)
enum b: BooleanType, A : a
var b<d where h: Int -> {
let a {
var b = [1)
enum B
protocol c<T where h: a {
case c
class a {
class A : AnyObject
func i(
class A : A {
typealias e : A
struct X<T : T
}
}
extension String {
let f = F>(
struct Q<T where H : b
var b = {
case c
protocol A : a {
struct d<T where B { func c
class A {
protocol P {
struct A : A
}
class b: a {
func c,
extension String {
func b
func < {
func < {
class A {
typealias e : T
protocol A {
func j<T {
protocol c
let f = compose() -> {
extension String {
for ( )"\(
{
class b
class A : C {
struct Q<T where h: Int -> {
typealias e : a
}
protocol A {
let t: AnyObject
protocol A : p
enum a<T {
}
extension String {
struct A : AnyObject
protocol A : P {
struct Q<T {
struct X<d {
struct B<c {
struct Q<T where h: e : T
struct Q<d where B :
struct d<T where d: b
let f = {
let f = c
class A : e)"[Void{
{
enum a
func b: p
let f = {
Void
struct S<T where g: b
struct B<T where h: p
for ( )"[Void
}
class a {
class a {
protocol A : a<T where h: e
for ( )"\() -> {
}
class A : BooleanType, A : AnyObject
class A {
extension String {
protocol A {
typealias e : e)"[Void{
}
struct X<d where h: A : a: e)"\() -> {
if true {
}
}
let t: d {
typeal
{
}
protocol c : a {
class a {
protocol A {
protocol A {
protocol c
}
struct Q<T where h: A
enum a: B
typealias e : e
protocol A : e)
enum B
struct A : Int = {
typealias e : a
}
let f = compose([Void{
protocol A : AnyObject
}
}
typealias e : C {
typealias e : a {
}
func i() {
let f = [Void{
protocol c<T {
}
class b<T where T where h: b
var b<T {
class b<T where h: A
struct X<S : BooleanType, A : a {
class a {
let t: Int -> {
struct B :
struct B : e)"\() -> {
struct B
protocol c {
struct S<T where B : CollectionType

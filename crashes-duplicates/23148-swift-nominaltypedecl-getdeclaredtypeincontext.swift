// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

protocol b(x: e {
var f = compose<I : A
func b{
typealias B<T where g: a {
if true {
class n {
class a {
extension NSSet {
protocol A:a{
var f = compose<T where g: NSObject {
class a{protocol e {
class a{
enum e where
func p("\(f<("\())"\(T: d
let i: NSObject {
let t: NSObject {
struct c
struct S<I : T) -> {
func e, g: U : ( ))){
import Foundation}
func a{
class A {
}}
[ ]
func a
b<T where g: A
{
}
}}
import Foundation
class B
func b
}
struct S<T {
let ( [{
}
func b{
class a
let a {}
[ ]
struct S<c<T where g: B {
func b{
extension NSSet {
class A {
func b<T {
}
struct c<T where g: B
println(x: ( ) -> U))"
println())"
let a {
}
}
}
{
init()"\(f<Q
struct S<T where g: B<T where g: d {
if true {
func b{
import Foundation
}
struct D : a {
}
va d<T where g
func f:a<T where g: Int -> {
compose<f<I : Int -> {
}class a
struct c<T
{
let a {
}
extension NSSet {
class b( [Void
S<Q
}class B
{
if true {}
struct c<T {
func f<f
class d
1
class b
}
func g: B<d : {
struct S<T
protocol b {let:a{
class B<
class A {
struct B
}class A
for b
class B {}
init(f:a
enum k {
enum k {
typealias B<T where g: U : B
for b
class A {
func <T {func f = c<T where g: Stri
for b{
protocol b{
protocol P {
protocol e {
class B<T {}
{
func g: T{
typealias F = {
func g: d : T: a {
S<T where g.B {
struct A {
class B
va d
enum e where h: a {
typealias f = b
let ( )"\(f<
}}
init(T) -> {
class A<f
func f<T where g: a {
import Foundation
}
struct S<T where g: Any, A:a
struct S<T where g: NSObject {
func p(T: T
typealias F = c
struct S<T where h: d: B
if true {
func e, g: T
{
func p("\(T
protocol A? {
struct S<Q
}T
}}
enum e where g: d<T where H : U : T: B
println(f
struct c<T where T) -> {
func a{}
}T: T: T) {
extension NSSet {
b{}
}
}
class A<T where h: d {
struct c<T {
func a<T
let i: Any, g.b
b
}
1
}
}
func f<T where h: B<T where h: {
func a
struct c
let i: B {
{
func p() -> U)"
for b<T where h: B
let a {
enum e {
class A? {
class B
class a{
compose<Q
}
struct S<Q
}class B
S<I : d {
let a {
let a {
for b(){
protocol b
}T) -> {
class a {
{
let a {
struct d
let i: NSObject {
for b{
import Foundation}
struct B
struct d<
extension NSSet {
struct S<T where h: Int -> U){
func a{
func g: T) { p() {

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

class
var d:d{
}}( f{
}( f
let b<d=(
class
case c,
{
typealias Tuple = (""}
case c,
{}
"""
let a
class
Void{return""}{
typealias e {
let b{
var : NSObject {
case c,
}extension
case
class
{return"}}
" " [ 1
{
case
case
{typealias B
}func e:e{
if true {typealias Tuple = <T NSObject {struct B<h:BooleanType{
}
}{func e typealias e{func e:d=(x: 0)
class A{
struct B<d=f{{
{
class B<T where g:a{class b{
("
class B<a{
{
var d{let t = (
case c,case
case
}
{
func<T:e{
class B
{
{class B<T {func a<h:e{func a<T{}
if true {
class a
typealias e {enum S<H:e
{
{ b = <T where h:a{}}{
where h:Int{{
{
{}class A{protocol a<a
}}}func e:d:d{var d{return"}
}extension
("
""}
struct B
class B
}}
{
class A{typealias e {
}class A{extension b=(Double, Double)
case c,
case c,
(
let a
case
case c,case
where b = < Array
typealias Tuple = (Double, y: b
struct B<d=f: b<T where b {{protocol b{
class
typealias Tuple = < Array<T:B<T:a{protocol b<T where B : b
""
class
class
struct B : a<a<T NSObject {
class n{var d{}class a<T where h:e{
let t = < Array
class A{
class
var _= < Array
case c,case
}
if true {
}class b{
class A{
var : 0.0.0.0)
{}}extension
}
"""
var d{typealias e typealias Tuple = < Array<T NSObject {func e {
" " [ 1
" [ 1
{
struct S<T NSObject {
typealias Tuple = (x: 0.0, y: 0.0, Double)
typealias e}func e {protocol a<T {
(T:a<a<T where B : Array
"
case
{ b = < Array
" [ 1
class B:a{
case c,case
{extension b{
(x: 0.0)
class
}}( f: a<T NSObject {func e {protocol b<T where f: b{var : 0.0.0.0)
typealias e:d=(x: Array<T where g:d=f{class b{
func<T where h:Int{
typealias e typealias Tuple = Tuple(T{}}class B<h:a
{enum S<H:e
{
"}
typealias e typealias Tuple = Tuple(
import Foundation
{
class B<a<T {
case c,
}
{enum S<H:e
{
" [ 1
}( f: NSObject {let a<T where g:Int{}
let b{
var d{
{
let d{return"
class
}}}
{
{var d{}
}{{
case
Void{let t = Tuple(""""}
case c,
func<T where b {
class
struct S<{protocol a
var _= Tuple(
struct A{
class A{
if true {var d{
class
}
}class b=f
Void{
class a
}class A{
(Double, Double, y: 0, y: 0.0)
{var d{
struct B:B<T where h:d{enum S<H:e
}
Void{
struct B
class
struct B:B<d{
class
"""
struct A{
let b=f
{
" " " " [ 1
}
case
var _= Tuple(Double, Double, Double

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

i>
0.a
struct A {
class
}
class a
class d<T> {
func a<T> : B, d where B : d.h
struct g<T where B : d
let end = [ {
class A {
case c,
let a {
"[Void{
func h=B<T>
func b:a{
typealias e:a
struct A
class
let end = [ {
let end = j
protocol a {
class
case c,
let end = a
let end = [Void{
{
let end = j
class
func b:a
let end = [ {
t ) {
func b
class
struct A {
class
println( ) {
for b {
class a {
func < = [Void{
let f = [Void{
protocol A<T where k.b { func h
typealias e = {
typealias e : e
class
func a"[Void{class a {
init( 1 )
let end = [ {
}
struct A {
case ,
func f
class A {
case c,
class a {
class
"
{
let end = a<T> (d
let end = j
var b { func a<d where f(d
protocol B : a {
typealias e : {
struct A {
func a<T where k.h=
let end = [ {
func a<d where k.a<T>: f:a<T:b:A<d = [ {
case ,
struct g<T>: a {
var b = [Void{
case c,
i: b {
class
let end = [Void{
struct S {
func e
struct A {
typealias e = B<d = j
D T where k.h
class
struct A<T> (a
class
let f = j
class A {
protocol a {
class A {
case c,
protocol B : b = [Void{
protocol c {
{
typealias e = [Void{
deinit {
enum S<T:a
{
D : P
class d
case c,
func a
class a
init( 1 )
case c,
var d where B : e
let end = [ {
case ,y)
let end = a<T where B : d<T>
i:b
}
typealias e : b {
struct A<d<d
class
let end = [Void{
class
func < <T>
let a {
}
let a<d where k.h
let a {
enum A {
class B : B<T>: a {
enum B? {
let a<T>: e
}
D {
class
case c,
typealias e = a<T where k.a<T>: d<d {}
deinit {
class
let end = [ {
{
0.b {
case c,
func a
"
let f = [Void{
class d : d.b { func b
var d where B : B? {
struct . {
struct A<l {
protocol A,
class A {
protocol a {
func a
struct c,
var b = [Void{
class A,
func b
struct A<T > (v: d<T where k.e : e
i>: d
struct c,
func a<T>
{
typealias e = [ {
var d where H : {
class
case c,
class a
protocol a {
protocol a {
{
let f = j
typealias e = [Void{
struct B? {
typealias e : d< <T where k.b {
let f = a{
"
let f = B<T where H : a {
let a {
deinit {
let i: e
}
case c,
let a
let end = B? {
{
deinit {
let a {
case c,
class
class a {
func a
protocol B : B, leng
var b { func b
typealias e.h
func f:A<T:A:a{
class a T>: b = [Void{class B : a {
typealias e = {
struct g<T where k.b = B? {
let a {
protocol A {
protocol B {
protocol a {
case c

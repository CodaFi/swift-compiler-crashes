// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

class B<T where g:AnyObject{
let t: A{
let start = [Void{struct B<b
typealias e : e{typealias F=b> {
protocol A{
protocol A{
return "
a}enum A{class A {
class A : NSObject {
typealias e {
typealias F=b<b where k.h> {
struct A? {
protocol A{
protocol A:B? {
struct c
var f = compose(t: Int = compose(map(
}
class b
class B<b
typealias b
struct c>() {
func a}
protocol A : e{
}
struct B
class B{
return "
var e
class d
typealias e : e
class d<b> {
protocol A {
protocol c
class d<T where g: T : BooleanType, A {{
extension g{
}
func b<T where k.h> {
typealias F== compose()?
class var d {
var f{
struct g:Int=b<T>(
class B{
extension g:e
a}
struct c:e
}1
extension g
let t: NSObject {
"
println(A{
typealias e : T : c:e: Array<T where g: B? {
func b
protocol A {
"
protocol A : Array<T where g:Int== e{
println((A? {
var:e
println()?
let t: A{
let start = compose(t: T where g:AnyObject{
struct B
protocol A {
}
extension g<b {
}
struct g: T where g: T where g<T>struct g
}
println(a!
}
var f{
typealias F== compose(t: e
}Void{
struct c
extension g:d<T where g<T where g: T where S<T>:a
class bb< {
"
class B{func a{
struct B<T where g: A{func b
protocol A : a {
}
struct
protocol A{
extension g<T>(
"
class B<b
var f{
var e
struct c>:e: Array<T where g:Int== [Void{
let start = e
var e:B? {
}
protocol A : Int = [Void{
}
}
let t: A? {
func g: Array<b where g: B<T : e
}
typealias F== e
}
class A : B? {
protocol c:A:A<T>struct B? {
{
class d
return "
class c:B
let t: Array<b<T where g:B:AnyObject{
var:A{
}
var f{func b
struct g
}
class A {
let:e{typealias e
class B
protocol A:a!
class bb< b where g<T where S<b
struct B? {
let start = [Void{
extension g<T : Array<b where S<T where g: Array<T where S<T where k.h> {
return "
extension g: NSObject {
typealias e : NSObject {
protocol A {
}
class d
struct c>:Int=(
let a{
struct c:e{
let t: e{
var:A){
}
protocol a}enum A? {
typealias e{
protocol A{
class b
protocol A {
class var f{class B? {
class b> {}
let t: B? {
class d<T where k.h> {
struct g<T where g
class d
class A {
protocol A : Array<T : B? {
struct A{class var f{
protocol A {
protocol A {
var f{
println(
func g: Array<b where k.h> {func a{}
protocol A {
var d {
class d
class d
}1
class bb< {
let:a
struct c:e: T : Int = compose(map((((
class A {class c>(t: a {func a{
class bb< {
typealias b< {
}
}
func b
class c{
protocol A {
extension g<b> {}
println((a
let t:

// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

protocol A : Array<T where A.c,
var _=(e {
}
struct B<T where B : A.c,
case c,
struct d
{
struct A : T where B : A
var d = B<S : Array<T where B : b {
}
class
case c
enum S<T {
let i: S<T where A.c] = 0.c,
protocol A {
var d where H.g : T
class
func a{
func b: A<T : A<b
struct d
struct d
class
class a{
func a.g : T func f: b {
func c,
}
class d<T where A<a<T
var d where B : A<
class
var d = 0
class
if true {
class A : P {
protocol A {
struct B<S : d
struct A? {{
class a: A : B)
let a {
typealias e =[Void{
class d
class
var d where g: d = "\()?
protocol a {
func f: A {
((v: d where H.e =(((((v: A {
(e([{
case c
class
class
protocol A {
let a {
struct d<T where H.c: A<T where H.dynamicType)
var d where H.c] = [{
func b== A.c,
var f : Int -> Void{
d
class a<T where g: T where A<S : d = a
return m((("
func b
Void{
var d where g: Any))?
enum S<T where A.g : T
struct A.e =(
var d where g: AnyObject.c
struct B:a{deinit{
let h = [Void{
class A {
class
{
if true {
class
let a {
{
([Void{
d<T where g: A.c] = [Void{
i: B? {
protocol e {
}
class
class a: T where g: d = B)?
println("
protocol A {
{
}
let a {
class
}
struct A {
import Foundation
class d<b> U)
var d {
struct A<T where I.c
{
struct d
class a<T : d = [Void{
i: b {
func a<Int>] = 0
struct d:AnyObject.d
typealias e : P {deinit{
func b
let a {(e == b
for c,
typealias e = 0
struct B
{
struct Q<Int
func a
func a<T where g: P {
class
protocol a = b: B<T where g: Any)
struct Q<T where g: NSObject {
func b== b: B, e
case c
let a = [Void{
{
(v: A
typealias b
struct A.c
class
class a: d{
struct B<T where A? = 0
}
protocol e : A {
([Void{struct Q<S : String {
func a<T where g: Any)"
return m(e: A
let i: A : T
case c,
class x{{
}
println()"
struct d<T : b {
class
d
struct d:AnyObject.c] = A? = 0.c,
class b
enum A {
{
class
class
case c
((v: d where f: Any
protocol a {
(\(v: A {
d: A{
protocol a {
i> U)"\(()"
if true {
}
{
}
{var d = B<T {
case c,
struct B<T>: Any
protocol A : B<b<I : T where A.c,
var d where A.c,
let i: A.d
}
typealias b
(e
let a {
struct B<T
let end = a<T>] = [Void{
{
struct d<T where g: S
let end = b
if true {
return m() as a: A : String {
case c,
return m(()"
typealias e : Array
